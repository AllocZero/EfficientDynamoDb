"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5739],{5404:(e,r,n)=>{n.d(r,{R:()=>s,x:()=>a});var t=n(6672);const i={},o=t.createContext(i);function s(e){const r=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(o.Provider,{value:r},e.children)}},8621:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>s,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"dev_guide/high_level/converters","title":"Converters","description":"A converter is a class that converts a .NET type to and from DynamoDB JSON or low-level Document object. A custom converter allows working with unsupported types or overriding the default converter behavior.","source":"@site/docs/dev_guide/high_level/converters.md","sourceDirName":"dev_guide/high_level","slug":"/dev-guide/high-level/converters","permalink":"/EfficientDynamoDb/docs/dev-guide/high-level/converters","draft":false,"unlisted":false,"editUrl":"https://github.com/alloczero/EfficientDynamoDb/edit/main/website/docs/dev_guide/high_level/converters.md","tags":[],"version":"current","frontMatter":{"id":"converters","title":"Converters","slug":"../../dev-guide/high-level/converters"},"sidebar":"someSidebar","previous":{"title":"Transactions","permalink":"/EfficientDynamoDb/docs/dev-guide/high-level/transact"},"next":{"title":"Building Conditions","permalink":"/EfficientDynamoDb/docs/dev-guide/high-level/conditions"}}');var i=n(3420),o=n(5404);const s={id:"converters",title:"Converters",slug:"../../dev-guide/high-level/converters"},a=void 0,l={},d=[{value:"Built-in converters",id:"built-in-converters",level:2},{value:"Applying converters",id:"applying-converters",level:2},{value:"For a property",id:"for-a-property",level:3},{value:"For a type",id:"for-a-type",level:3},{value:"For a context",id:"for-a-context",level:3},{value:"Basic converter",id:"basic-converter",level:2},{value:"Direct JSON converter",id:"direct-json-converter",level:2},{value:"JSON reading",id:"json-reading",level:3},{value:"JSON writing",id:"json-writing",level:3},{value:"Sparse converters",id:"sparse-converters",level:2},{value:"Set converters",id:"set-converters",level:2},{value:"Dictionary key converters",id:"dictionary-key-converters",level:2}];function c(e){const r={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(r.p,{children:["A converter is a class that converts a .NET type to and from DynamoDB JSON or low-level ",(0,i.jsx)(r.code,{children:"Document"})," object. A custom converter allows working with unsupported types or overriding the default converter behavior."]}),"\n",(0,i.jsxs)(r.p,{children:["Converters, along with with DynamoDB JSON parsing, are one of the most critical components from a performance perspective.\nAll ",(0,i.jsx)(r.strong,{children:"EfficientDynamoDb"})," built-in converters are optimized separately for both ",(0,i.jsx)(r.code,{children:"Document"})," and JSON conversion, in order to allocate no additional memory."]}),"\n",(0,i.jsx)(r.h2,{id:"built-in-converters",children:"Built-in converters"}),"\n",(0,i.jsx)(r.p,{children:"EfficientDynamoDb does not require specifying a converter explicitly for the following built-in types:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Classes"}),"\n",(0,i.jsx)(r.li,{children:"Strings"}),"\n",(0,i.jsxs)(r.li,{children:["Numbers: ",(0,i.jsx)(r.code,{children:"byte"}),", ",(0,i.jsx)(r.code,{children:"short"}),", ",(0,i.jsx)(r.code,{children:"int"}),", ",(0,i.jsx)(r.code,{children:"long"}),", ",(0,i.jsx)(r.code,{children:"decimal"}),", ",(0,i.jsx)(r.code,{children:"float"}),", ",(0,i.jsx)(r.code,{children:"double"}),", ",(0,i.jsx)(r.code,{children:"ushort"}),", ",(0,i.jsx)(r.code,{children:"uint"}),", ",(0,i.jsx)(r.code,{children:"ulong"})]}),"\n",(0,i.jsx)(r.li,{children:"Enums (saved as numbers)"}),"\n",(0,i.jsx)(r.li,{children:"DateTimes (saved in ISO8601 format)"}),"\n",(0,i.jsx)(r.li,{children:"Guids"}),"\n",(0,i.jsx)(r.li,{children:"Booleans"}),"\n",(0,i.jsx)(r.li,{children:"Collections: arrays, lists, dictionaries, sets (including their read-only and mutable interfaces)"}),"\n",(0,i.jsxs)(r.li,{children:["Binary data: ",(0,i.jsx)(r.code,{children:"byte[]"}),", ",(0,i.jsx)(r.code,{children:"Memory<byte>"}),", ",(0,i.jsx)(r.code,{children:"ReadOnlyMemory<byte>"})]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"AttributeValue"})," structs (low-level API representation of the DynamoDB attribute)"]}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"In addition, you can use one of the following converters to change the default behavior:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"StringEnumDdbConverter<T>"})," - saves enums as strings instead of numbers."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"DateTimeDdbConverter"})," - allows to customize ",(0,i.jsx)(r.code,{children:"DateTime"})," formatting parameters: ",(0,i.jsx)(r.code,{children:"Format"}),", ",(0,i.jsx)(r.code,{children:"DateTimeStyles"})," and ",(0,i.jsx)(r.code,{children:"CultureInfo"}),"."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"SdkDateTimeDdbConverter"})," - makes ",(0,i.jsx)(r.code,{children:"DateTime"})," behavior backward compatible with the official AWS SDK."]}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"applying-converters",children:"Applying converters"}),"\n",(0,i.jsx)(r.h3,{id:"for-a-property",children:"For a property"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-csharp",children:'[DynamoDbProperty("address", typeof(CompositeAddressConverter))]\npublic Address Address { get; set; }\n'})}),"\n",(0,i.jsx)(r.h3,{id:"for-a-type",children:"For a type"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-csharp",children:"[DynamoDbConverter(typeof(CompositeAddressConverter))]\npublic struct Address { ... }\n"})}),"\n",(0,i.jsx)(r.h3,{id:"for-a-context",children:"For a context"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-csharp",children:"var config = new DynamoDbContextConfig(regionEndpoint, awsCredentials)\n{\n    Converters = new[] {new CompositeAddressConverter()}\n};\n"})}),"\n",(0,i.jsxs)(r.p,{children:["If a converter can't be instantiated in advance and depends on the target value type, a custom converter factory can be implemented by inheriting from the ",(0,i.jsx)(r.code,{children:"DdbConverterFactory"})," class and registering it with the context the same way as other custom converters."]}),"\n",(0,i.jsx)(r.p,{children:"For example, a string enum converter factory can be defined like this:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-csharp",children:"public sealed class StringEnumDdbConverterFactory : DdbConverterFactory\n{\n    public override bool CanConvert(Type typeToConvert) => typeToConvert.IsEnum;\n\n    public override DdbConverter CreateConverter(Type typeToConvert, DynamoDbContextMetadata metadata)\n    {\n        return (DdbConverter) Activator.CreateInstance(typeof(StringEnumDdbConverter<>).MakeGenericType(typeToConvert));\n    }\n}\n"})}),"\n",(0,i.jsx)(r.h2,{id:"basic-converter",children:"Basic converter"}),"\n",(0,i.jsx)(r.p,{children:"To create a custom converter:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["Inherit from ",(0,i.jsx)(r.code,{children:"DdbConverter<TValue>"})," class."]}),"\n",(0,i.jsxs)(r.li,{children:["Implement both ",(0,i.jsx)(r.code,{children:"Read"})," and ",(0,i.jsx)(r.code,{children:"Write"})," methods."]}),"\n"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-csharp",children:"public class CompositeAddressConverter : DdbConverter<Address>\n{\n    // Converts DynamoDb attribute to the .NET type\n    public override Address Read(in AttributeValue attributeValue)\n    {\n        var parts = attributeValue.AsString().Split('#');\n        return new Address(parts[0], parts[1]);\n    }\n\n    // Converts .NET type to the DynamoDb attribute\n    public override AttributeValue Write(ref Address address)\n    {\n        return new StringAttributeValue($\"{address.Country}#{address.Street}\");\n    }\n}\n"})}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsxs)(r.em,{children:["Check out the ",(0,i.jsx)(r.a,{href:"/EfficientDynamoDb/docs/dev-guide/low-level#working-with-documents",children:"working with documents"})," chapter to better understand how to work with attribute values."]})}),"\n",(0,i.jsx)(r.h2,{id:"direct-json-converter",children:"Direct JSON converter"}),"\n",(0,i.jsxs)(r.p,{children:["Not all .NET types map nicely to DynamoDb attributes. Creation of intermediate ",(0,i.jsx)(r.code,{children:"AttributeValue"})," struct can involve unnecessary allocations that can be avoided by reading/writing directly into JSON buffer.\nIn case when a custom type can't be converted to the ",(0,i.jsx)(r.code,{children:"AttributeValue"})," without allocations, it is possible to implement two additional low-level ",(0,i.jsx)(r.code,{children:"Read"})," and ",(0,i.jsx)(r.code,{children:"Write"})," methods that work with JSON buffers.\nDuring deserialization/serialization of entities to JSON, more optimized low-level implementations will be called."]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-csharp",children:"public class CustomIntConverter : DdbConverter<int>\n{\n    // Efficient zero-allocation JSON to int conversion\n    public override int Read(ref DdbReader reader)\n    {\n        if (!Utf8Parser.TryParse(reader.JsonReader.ValueSpan, out int value, out _))\n            throw new DdbException($\"Couldn't parse int ddb value from '{reader.JsonReader.GetString()}'.\");\n\n        return value;\n    }\n    \n    // Efficient zero-allocation int to JSON conversion\n    public override void Write(in DdbWriter writer, ref int value)\n    {\n         writer.JsonWriter.WriteStartObject();\n         writer.JsonWriter.WriteString(DdbTypeNames.Number, value);\n         writer.JsonWriter.WriteEndObject();\n    }\n    \n    public override int Read(in AttributeValue attributeValue) => attributeValue.AsNumberAttribute().ToInt();\n    \n    public override AttributeValue Write(ref int value) => new NumberAttributeValue(value.ToString());   \n}\n"})}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"EfficientDynamoDb"})," uses ",(0,i.jsx)(r.code,{children:"System.Text.Json"})," for all JSON manipulations."]}),"\n",(0,i.jsx)(r.h3,{id:"json-reading",children:"JSON reading"}),"\n",(0,i.jsxs)(r.p,{children:["When a low-level read is called, ",(0,i.jsx)(r.code,{children:"DdbReader.JsonReader"})," is already pointed to the JSON value. Current attribute type is automatically parsed and can be accessed using ",(0,i.jsx)(r.code,{children:"DdbReader.AttributeType"})," property."]}),"\n",(0,i.jsxs)(r.p,{children:["The ",(0,i.jsx)(r.code,{children:"reader.JsonReader.HasValueSequence"})," is guaranteed to be false at this point, so it's safe to use ",(0,i.jsx)(r.code,{children:"reader.JsonReader.ValueSpan"})," to access the JSON buffer."]}),"\n",(0,i.jsxs)(r.p,{children:["The ",(0,i.jsx)(r.code,{children:"DdbReader.JsonReader.Read"})," method should not be explicitly called unless you are writing a converter for a non-scalar DynamoDB data type - i.e., a map, list or set."]}),"\n",(0,i.jsx)(r.h3,{id:"json-writing",children:"JSON writing"}),"\n",(0,i.jsxs)(r.p,{children:["When a low-level write is called, a converter has to write DynamoDb JSON, including the attribute type.\n",(0,i.jsx)(r.code,{children:"DdbWriter"})," class provides various simplified overloads that write attribute types automatically. But in case if suitable overload does not exist, the attribute type has to be written manually like in the ",(0,i.jsx)(r.code,{children:"CustomIntConverter"})," example above."]}),"\n",(0,i.jsx)(r.h2,{id:"sparse-converters",children:"Sparse converters"}),"\n",(0,i.jsx)(r.p,{children:"Sparse converters don't save certain values and completely remove an attribute instead. It is a powerful concept that can be used for various purposes like size savings or to conditionally include an entity in the GSI."}),"\n",(0,i.jsxs)(r.p,{children:["By default, all built-in converters act as sparse converters when it comes to handling ",(0,i.jsx)(r.code,{children:"null"})," values, meaning that ",(0,i.jsx)(r.code,{children:"null"})," properties are never saved and the entire attribute is deleted."]}),"\n",(0,i.jsxs)(r.p,{children:["To add an additional sparse condition, ",(0,i.jsx)(r.code,{children:"ShouldWrite"})," method has to be overridden. For example. here is a simple sparse int converter:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-csharp",children:"public class SparseIntConverter : DdbConverter<int>\n{\n    public override bool ShouldWrite(ref int value) => value != 0;\n    \n    ...\n}\n"})}),"\n",(0,i.jsxs)(r.p,{children:["Note: Sparse converters don't remove attributes when they are part of a ",(0,i.jsx)(r.code,{children:"Dictionary"})," class."]}),"\n",(0,i.jsx)(r.h2,{id:"set-converters",children:"Set converters"}),"\n",(0,i.jsxs)(r.p,{children:["Both string and number sets store values as strings in the DB.\nTo store a custom type inside a set, a converter should implement the ",(0,i.jsx)(r.code,{children:"ISetValueConverter<T>"})," interface:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-csharp",children:"public class CustomDdbConverter : DdbConverter<CustomType>, ISetValueConverter<CustomType>\n{\n    public string WriteStringValue(ref CustomType value) => value.ToString();\n    \n    // Optionally implement direct write method\n    public void WriteStringValue(in DdbWriter ddbWriter, ref CustomType value) => \n        ddbWriter.JsonWriter.WriteStringValue(value.AsSpan());\n}\n"})}),"\n",(0,i.jsx)(r.h2,{id:"dictionary-key-converters",children:"Dictionary key converters"}),"\n",(0,i.jsxs)(r.p,{children:["To store a custom type as a dictionary key, a converter should implement the ",(0,i.jsx)(r.code,{children:"IDicitonaryKeyConverter<T>"})," interface:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-csharp",children:"public class CustomDdbConverter : DdbConverter<CustomType>, ISetValueConverter<CustomType>\n{\n    public string WriteStringValue(ref CustomType value) => value.ToString();\n    \n    // Optionally implement direct write method\n    public void WritePropertyName(in DdbWriter ddbWriter, ref CustomType value) => \n        ddbWriter.JsonWriter.WritePropertyName(value.AsSpan());\n}\n"})})]})}function u(e={}){const{wrapper:r}={...(0,o.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);