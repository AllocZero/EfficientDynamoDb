"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5739],{5404:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>a});var t=r(6672);const i={},s=t.createContext(i);function o(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(s.Provider,{value:n},e.children)}},8621:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"dev_guide/high_level/converters","title":"Converters","description":"A converter is a class that converts a .NET type to and from DynamoDB JSON or low-level Document object. A custom converter allows working with unsupported types or overriding the default converter behavior.","source":"@site/docs/dev_guide/high_level/converters.md","sourceDirName":"dev_guide/high_level","slug":"/dev-guide/high-level/converters","permalink":"/EfficientDynamoDb/docs/dev-guide/high-level/converters","draft":false,"unlisted":false,"editUrl":"https://github.com/alloczero/EfficientDynamoDb/edit/main/website/docs/dev_guide/high_level/converters.md","tags":[],"version":"current","frontMatter":{"id":"converters","title":"Converters","slug":"../../dev-guide/high-level/converters"},"sidebar":"someSidebar","previous":{"title":"Transactions","permalink":"/EfficientDynamoDb/docs/dev-guide/high-level/transact"},"next":{"title":"Building Conditions","permalink":"/EfficientDynamoDb/docs/dev-guide/high-level/conditions"}}');var i=r(3420),s=r(5404);const o={id:"converters",title:"Converters",slug:"../../dev-guide/high-level/converters"},a=void 0,l={},d=[{value:"Built-in converters",id:"built-in-converters",level:2},{value:"Applying converters",id:"applying-converters",level:2},{value:"For a property",id:"for-a-property",level:3},{value:"For a type",id:"for-a-type",level:3},{value:"For a context",id:"for-a-context",level:3},{value:"Basic converter",id:"basic-converter",level:2},{value:"Direct JSON converter",id:"direct-json-converter",level:2},{value:"JSON reading",id:"json-reading",level:3},{value:"Parsing DynamoDB lists and arrays",id:"parsing-dynamodb-lists-and-arrays",level:4},{value:"JSON writing",id:"json-writing",level:3},{value:"Sparse converters",id:"sparse-converters",level:2},{value:"Set converters",id:"set-converters",level:2},{value:"Dictionary key converters",id:"dictionary-key-converters",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["A converter is a class that converts a .NET type to and from DynamoDB JSON or low-level ",(0,i.jsx)(n.code,{children:"Document"})," object. A custom converter allows working with unsupported types or overriding the default converter behavior."]}),"\n",(0,i.jsxs)(n.p,{children:["Converters, along with with DynamoDB JSON parsing, are one of the most critical components from a performance perspective.\nAll ",(0,i.jsx)(n.strong,{children:"EfficientDynamoDb"})," built-in converters are optimized separately for both ",(0,i.jsx)(n.code,{children:"Document"})," and JSON conversion, in order to allocate no additional memory."]}),"\n",(0,i.jsx)(n.h2,{id:"built-in-converters",children:"Built-in converters"}),"\n",(0,i.jsx)(n.p,{children:"EfficientDynamoDb does not require specifying a converter explicitly for the following built-in types:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Classes"}),"\n",(0,i.jsx)(n.li,{children:"Strings"}),"\n",(0,i.jsxs)(n.li,{children:["Numbers: ",(0,i.jsx)(n.code,{children:"byte"}),", ",(0,i.jsx)(n.code,{children:"short"}),", ",(0,i.jsx)(n.code,{children:"int"}),", ",(0,i.jsx)(n.code,{children:"long"}),", ",(0,i.jsx)(n.code,{children:"decimal"}),", ",(0,i.jsx)(n.code,{children:"float"}),", ",(0,i.jsx)(n.code,{children:"double"}),", ",(0,i.jsx)(n.code,{children:"ushort"}),", ",(0,i.jsx)(n.code,{children:"uint"}),", ",(0,i.jsx)(n.code,{children:"ulong"})]}),"\n",(0,i.jsx)(n.li,{children:"Enums (saved as numbers)"}),"\n",(0,i.jsxs)(n.li,{children:["Time-related types (saved in round-trip ISO8601 format): ",(0,i.jsx)(n.code,{children:"DateTime"}),", ",(0,i.jsx)(n.code,{children:"DateTimeOffset"}),", ",(0,i.jsx)(n.code,{children:"DateOnly"}),", ",(0,i.jsx)(n.code,{children:"TimeOnly"})]}),"\n",(0,i.jsx)(n.li,{children:"Guids"}),"\n",(0,i.jsx)(n.li,{children:"Booleans"}),"\n",(0,i.jsx)(n.li,{children:"Collections: arrays, lists, dictionaries, sets (including their read-only and mutable interfaces)"}),"\n",(0,i.jsxs)(n.li,{children:["Binary data: ",(0,i.jsx)(n.code,{children:"byte[]"}),", ",(0,i.jsx)(n.code,{children:"Memory<byte>"}),", ",(0,i.jsx)(n.code,{children:"ReadOnlyMemory<byte>"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"AttributeValue"})," structs (low-level API representation of the DynamoDB attribute)"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"In addition, you can use one of the following converters to change the default behavior:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"StringEnumDdbConverter<T>"})," - saves enums as strings instead of numbers."]}),"\n",(0,i.jsxs)(n.li,{children:["Time converters - allow to customize ",(0,i.jsx)(n.code,{children:"DateTime"})," formatting parameters: ",(0,i.jsx)(n.code,{children:"Format"}),", ",(0,i.jsx)(n.code,{children:"DateTimeStyles"})," and ",(0,i.jsx)(n.code,{children:"CultureInfo"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"DateTimeDdbConverter"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"DateTimeOffsetDdbConverter"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"DateOnlyDdbConverter"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"TimeOnlyDdbConverter"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"SdkDateTimeDdbConverter"})," - makes ",(0,i.jsx)(n.code,{children:"DateTime"})," behavior backward compatible with the official AWS SDK."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"applying-converters",children:"Applying converters"}),"\n",(0,i.jsx)(n.h3,{id:"for-a-property",children:"For a property"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'[DynamoDbProperty("address", typeof(CompositeAddressConverter))]\npublic Address Address { get; set; }\n'})}),"\n",(0,i.jsx)(n.h3,{id:"for-a-type",children:"For a type"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"[DynamoDbConverter(typeof(CompositeAddressConverter))]\npublic struct Address { ... }\n"})}),"\n",(0,i.jsx)(n.h3,{id:"for-a-context",children:"For a context"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"var config = new DynamoDbContextConfig(regionEndpoint, awsCredentials)\n{\n    Converters = new[] {new CompositeAddressConverter()}\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If a converter can't be instantiated in advance and depends on the target value type, a custom converter factory can be implemented by inheriting from the ",(0,i.jsx)(n.code,{children:"DdbConverterFactory"})," class and registering it with the context the same way as other custom converters."]}),"\n",(0,i.jsx)(n.p,{children:"For example, a string enum converter factory can be defined like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"public sealed class StringEnumDdbConverterFactory : DdbConverterFactory\n{\n    public override bool CanConvert(Type typeToConvert) => typeToConvert.IsEnum;\n\n    public override DdbConverter CreateConverter(Type typeToConvert, DynamoDbContextMetadata metadata)\n    {\n        return (DdbConverter) Activator.CreateInstance(typeof(StringEnumDdbConverter<>).MakeGenericType(typeToConvert));\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"basic-converter",children:"Basic converter"}),"\n",(0,i.jsx)(n.p,{children:"To create a custom converter:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Inherit from ",(0,i.jsx)(n.code,{children:"DdbConverter<TValue>"})," class."]}),"\n",(0,i.jsxs)(n.li,{children:["Implement both ",(0,i.jsx)(n.code,{children:"Read"})," and ",(0,i.jsx)(n.code,{children:"Write"})," methods."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"public class CompositeAddressConverter : DdbConverter<Address>\n{\n    // Converts DynamoDb attribute to the .NET type\n    public override Address Read(in AttributeValue attributeValue)\n    {\n        var parts = attributeValue.AsString().Split('#');\n        return new Address(parts[0], parts[1]);\n    }\n\n    // Converts .NET type to the DynamoDb attribute\n    public override AttributeValue Write(ref Address address)\n    {\n        return new StringAttributeValue($\"{address.Country}#{address.Street}\");\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.em,{children:["Check out the ",(0,i.jsx)(n.a,{href:"/EfficientDynamoDb/docs/dev-guide/low-level#working-with-documents",children:"working with documents"})," chapter to better understand how to work with attribute values."]})}),"\n",(0,i.jsx)(n.h2,{id:"direct-json-converter",children:"Direct JSON converter"}),"\n",(0,i.jsxs)(n.p,{children:["Not all .NET types map nicely to DynamoDb attributes. Creation of intermediate ",(0,i.jsx)(n.code,{children:"AttributeValue"})," struct can involve unnecessary allocations that can be avoided by reading/writing directly into JSON buffer.\nIn case when a custom type can't be converted to the ",(0,i.jsx)(n.code,{children:"AttributeValue"})," without allocations, it is possible to implement two additional low-level ",(0,i.jsx)(n.code,{children:"Read"})," and ",(0,i.jsx)(n.code,{children:"Write"})," methods that work with JSON buffers.\nDuring deserialization/serialization of entities to JSON, more optimized low-level implementations will be called."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"public class CustomIntConverter : DdbConverter<int>\n{\n    // Efficient zero-allocation JSON to int conversion\n    public override int Read(ref DdbReader reader)\n    {\n        if (!Utf8Parser.TryParse(reader.JsonReaderValue.ValueSpan, out int value, out _))\n            throw new DdbException($\"Couldn't parse int ddb value from '{reader.JsonReaderValue.GetString()}'.\");\n\n        return value;\n    }\n    \n    // Efficient zero-allocation int to JSON conversion\n    public override void Write(in DdbWriter writer, ref int value)\n    {\n         writer.JsonWriter.WriteStartObject();\n         writer.JsonWriter.WriteString(DdbTypeNames.Number, value);\n         writer.JsonWriter.WriteEndObject();\n    }\n    \n    public override int Read(in AttributeValue attributeValue) => attributeValue.AsNumberAttribute().ToInt();\n    \n    public override AttributeValue Write(ref int value) => new NumberAttributeValue(value.ToString());   \n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"EfficientDynamoDb"})," uses ",(0,i.jsx)(n.code,{children:"System.Text.Json"})," for all JSON manipulations."]}),"\n",(0,i.jsx)(n.h3,{id:"json-reading",children:"JSON reading"}),"\n",(0,i.jsxs)(n.p,{children:["When a low-level read is called, ",(0,i.jsx)(n.code,{children:"DdbReader.JsonReaderValue"})," is already pointed to the JSON value. Current attribute type is automatically parsed and can be accessed using ",(0,i.jsx)(n.code,{children:"DdbReader.AttributeType"})," property."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"reader.JsonReaderValue.HasValueSequence"})," is guaranteed to be false at this point, so it's safe to use ",(0,i.jsx)(n.code,{children:"reader.JsonReaderValue.ValueSpan"})," to access the JSON buffer."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"ref reader.JsonReaderValue.Read()"})," method should not be explicitly called unless you are writing a converter for a non-scalar DynamoDB data type - i.e., a map, list or set. When reading non-scalar types, you must use ",(0,i.jsx)(n.code,{children:"ref"})," to access ",(0,i.jsx)(n.code,{children:"JsonReaderValue"})," to ensure the reader advances correctly through the JSON structure."]}),"\n",(0,i.jsx)(n.h4,{id:"parsing-dynamodb-lists-and-arrays",children:"Parsing DynamoDB lists and arrays"}),"\n",(0,i.jsxs)(n.p,{children:["By default, EfficientDynamoDb automatically parses DynamoDB collections (lists, sets and maps) into .NET collections and dictionaries.\nHowever, if you need to parse a DynamoDB list (array) into a custom type, you can implement the ",(0,i.jsx)(n.code,{children:"Read"})," method manually."]}),"\n",(0,i.jsx)(n.p,{children:"When parsing a DynamoDB collection, you need to manually advance through the JSON tokens. Assuming the following DDB JSON for a list of strings:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'[\n    { "S": "value1" },\n    { "S": "value2" },\n    { "S": "value3" }\n]\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The following converter will parse this list into a separator-delimited string, e.g. ",(0,i.jsx)(n.code,{children:"value1#value2#value3"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"public class StringListConverter : DdbConverter<string>\n{\n    // High-level methods are skipped for simplicity in this example.\n\n    public override string Read(ref DdbReader reader)\n    {\n        ref var jsonReader = ref reader.JsonReaderValue;\n        // jsonReader is pointing to the StartArray token\n\n        var result = new List<string>();\n        while (jsonReader.TokenType != JsonTokenType.EndArray)\n        {\n            // Read StartObject token\n            jsonReader.Read();\n            \n            // Read property name (\"S\" for string)\n            jsonReader.Read();\n            \n            // Read string value\n            jsonReader.Read();\n            result.Add(jsonReader.GetString());\n            \n            // Read EndObject token\n            jsonReader.Read();\n        }\n        \n        // Read EndArray token\n        jsonReader.Read();\n        \n        return string.Join('#', result);\n    }\n}\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["Always use ",(0,i.jsx)(n.code,{children:"ref"})," when accessing ",(0,i.jsx)(n.code,{children:"JsonReaderValue"})," to call ",(0,i.jsx)(n.code,{children:"Read()"})," or access its properties. This ensures the reader state advances correctly. Using the obsolete ",(0,i.jsx)(n.code,{children:"JsonReader"})," property (which returns a copy) will not advance the underlying reader and will cause parsing errors."]})}),"\n",(0,i.jsx)(n.admonition,{type:"caution",children:(0,i.jsx)(n.p,{children:"Leaving the reader in invalid state can cause parsing errors for the whole entity. It is the responsibility of the converter to ensure the reader is in a valid state after reading."})}),"\n",(0,i.jsx)(n.h3,{id:"json-writing",children:"JSON writing"}),"\n",(0,i.jsxs)(n.p,{children:["When a low-level write is called, a converter has to write DynamoDb JSON, including the attribute type.\n",(0,i.jsx)(n.code,{children:"DdbWriter"})," class provides various simplified overloads that write attribute types automatically. But in case if suitable overload does not exist, the attribute type has to be written manually like in the ",(0,i.jsx)(n.code,{children:"CustomIntConverter"})," example above."]}),"\n",(0,i.jsx)(n.h2,{id:"sparse-converters",children:"Sparse converters"}),"\n",(0,i.jsx)(n.p,{children:"Sparse converters don't save certain values and completely remove an attribute instead. It is a powerful concept that can be used for various purposes like size savings or to conditionally include an entity in the GSI."}),"\n",(0,i.jsxs)(n.p,{children:["By default, all built-in converters act as sparse converters when it comes to handling ",(0,i.jsx)(n.code,{children:"null"})," values, meaning that ",(0,i.jsx)(n.code,{children:"null"})," properties are never saved and the entire attribute is deleted."]}),"\n",(0,i.jsxs)(n.p,{children:["To add an additional sparse condition, ",(0,i.jsx)(n.code,{children:"ShouldWrite"})," method has to be overridden. For example. here is a simple sparse int converter:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"public class SparseIntConverter : DdbConverter<int>\n{\n    public override bool ShouldWrite(ref int value) => value != 0;\n    \n    ...\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Note: Sparse converters don't remove attributes when they are part of a ",(0,i.jsx)(n.code,{children:"Dictionary"})," class."]}),"\n",(0,i.jsx)(n.h2,{id:"set-converters",children:"Set converters"}),"\n",(0,i.jsxs)(n.p,{children:["Both string and number sets store values as strings in the DB.\nTo store a custom type inside a set, a converter should implement the ",(0,i.jsx)(n.code,{children:"ISetValueConverter<T>"})," interface:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"public class CustomDdbConverter : DdbConverter<CustomType>, ISetValueConverter<CustomType>\n{\n    public string WriteStringValue(ref CustomType value) => value.ToString();\n    \n    // Optionally implement direct write method\n    public void WriteStringValue(in DdbWriter ddbWriter, ref CustomType value) => \n        ddbWriter.JsonWriter.WriteStringValue(value.AsSpan());\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"dictionary-key-converters",children:"Dictionary key converters"}),"\n",(0,i.jsxs)(n.p,{children:["To store a custom type as a dictionary key, a converter should implement the ",(0,i.jsx)(n.code,{children:"IDicitonaryKeyConverter<T>"})," interface:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"public class CustomDdbConverter : DdbConverter<CustomType>, ISetValueConverter<CustomType>\n{\n    public string WriteStringValue(ref CustomType value) => value.ToString();\n    \n    // Optionally implement direct write method\n    public void WritePropertyName(in DdbWriter ddbWriter, ref CustomType value) => \n        ddbWriter.JsonWriter.WritePropertyName(value.AsSpan());\n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);