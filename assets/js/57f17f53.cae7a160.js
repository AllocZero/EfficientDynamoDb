"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1270],{744:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"whats-new-0.9.15","metadata":{"permalink":"/EfficientDynamoDb/blog/whats-new-0.9.15","editUrl":"https://github.com/alloczero/EfficientDynamoDb/edit/main/website/blog/blog/2024-02-04-whats-new-v0.9.15.md","source":"@site/blog/2024-02-04-whats-new-v0.9.15.md","title":"What\'s New in EfficientDynamoDb 0.9.15","description":"It has been a long time since the latest stable release of EfficientDynamoDb, but I\'m glad to announce that v0.9.15 is finally here.","date":"2024-02-04T00:00:00.000Z","formattedDate":"February 4, 2024","tags":[{"label":"release","permalink":"/EfficientDynamoDb/blog/tags/release"},{"label":"dynamodb","permalink":"/EfficientDynamoDb/blog/tags/dynamodb"},{"label":"dotnet","permalink":"/EfficientDynamoDb/blog/tags/dotnet"},{"label":"c#","permalink":"/EfficientDynamoDb/blog/tags/c"},{"label":"aws","permalink":"/EfficientDynamoDb/blog/tags/aws"}],"readingTime":2.94,"hasTruncateMarker":false,"authors":[{"name":"Mykhailo Matviiv","url":"https://github.com/firenero","imageURL":"https://avatars.githubusercontent.com/u/9461703?s=400&u=a677c383395a1debb6ae6fe1a50d6b039b28f203&v=4"}],"frontMatter":{"slug":"whats-new-0.9.15","title":"What\'s New in EfficientDynamoDb 0.9.15","author":"Mykhailo Matviiv","author_url":"https://github.com/firenero","author_image_url":"https://avatars.githubusercontent.com/u/9461703?s=400&u=a677c383395a1debb6ae6fe1a50d6b039b28f203&v=4","tags":["release","dynamodb","dotnet","c#","aws"]},"nextItem":{"title":"Welcome","permalink":"/EfficientDynamoDb/blog/welcome"}},"content":"It has been a long time since the latest stable release of EfficientDynamoDb, but I\'m glad to announce that [v0.9.15](https://github.com/AllocZero/EfficientDynamoDb/releases/tag/effddb-v0.9.15) is finally here.\\n\\n:::info\\nThis release brings support for the `ReturnValuesOnConditionCheckFailure` parameter in write requests, more predefined region endpoints, improved performance of error parsing, and XML docs for UpdateExpression builder.\\n:::\\n\\n## Support for `ReturnValuesOnConditionCheckFailure` feature\\n\\nThis parameter allows you to receive an item as it existed during the failed write attempt.\\nIt aids in reducing RCU usage and latency for initiating an additional `GetItem` request to understand why exactly your condition check failed.\\n\\nLet\'s consider the following example.\\nYou are developing a warehouse management system or internet store that allows employees to adjust item quantity.\\nA simplified data model for an item might look similar to this:\\n\\n```csharp\\n[DynamoDbTable(\\"items\\")]\\npublic class Item \\n{\\n    [DynamoDbProperty(\\"pk\\", DynamoDbAttributeType.PartitionKey)]\\n    public string WarehouseId { get; set; }\\n\\n    [DynamoDbProperty(\\"sk\\", DynamoDbAttributeType.SortKey)]\\n    public string ItemId { get; set; }\\n\\n    [DynamoDbProperty(\\"quantity\\")]\\n    public int Quantity { get; set; }\\n}\\n```\\n\\nNow, imagine a situation where two employees are trying to sell the same item to customers at the same time.\\nIn this case, you need to ensure that there are enough items in the warehouse before you finalize the deal.\\nAnd if there are not enough items for sale, inform the employee about how many items are currently available.\\n\\nBefore `ReturnValuesOnConditionCheckFailure`, the method that performs this function might look similar to this:\\n\\n```csharp\\npublic async Task SellItemsAsync(string warehouseId, string itemId, int quantity)\\n{\\n    try \\n    {\\n        await _context.UpdateItem<Item>()\\n            .WithPrimaryKey(warehouseId, itemId)\\n            .WithCondition(cond => cond.On(x => x.Balance).GreaterThanOrEqualTo(10))\\n            .ExecuteAsync();\\n    }\\n    catch (ConditionalCheckFailedException e)\\n    {\\n        // Not enough items available but no way to tell how many are left.\\n        // So we need to perform an additional GetItem request.\\n        var item = await _context.GetItemAsync<Item>(warehouseId, itemId);\\n        throw new InsufficientInventoryException(item.Balance);\\n    }\\n}\\n```\\n\\nThere are two main issues with this approach:\\n\\n1. Additional RSU is used for the `GetItem` request, which increases your DynamoDB bill.\\nIt becomes worse if you consider eventual consistency and opt for strongly consistent reads as they are twice as costly.\\n2. Additional latency is added due to a full round trip required for the `GetItem` request.\\n\\n`ReturnValuesOnConditionCheckFailure` addresses both these problems:\\n\\n```csharp\\npublic async Task SellItemsAsync(string warehouseId, string itemId, int quantity)\\n{\\n    try \\n    {\\n        await _context.UpdateItem<Item>()\\n            .WithPrimaryKey(warehouseId, itemId)\\n            .WithCondition(cond => cond.On(x => x.Balance).GreaterThanOrEqualTo(10))\\n            .WithReturnValuesOnConditionCheckFailure(ReturnValuesOnConditionCheckFailure.AllOld)\\n            .ExecuteAsync();\\n    }\\n    catch (ConditionalCheckFailedException e)\\n    {\\n        // Now the exception contains `Item` property. \\n        // It will be set only if WithReturnValuesOnConditionCheckFailure is set.\\n        // Note that it\'s a `Document` type that you can convert to an entity.\\n        var item = _context.ToEntity<Wallet>(e.Item!);\\n        throw new InsufficientInventoryException(item.Balance);\\n    }\\n}\\n```\\n\\nUsing this approach, you receive the balance as it existed at the exact moment of the failed update request, without incurring additional costs or latency in your system.\\n\\n:::note\\n`ReturnValuesOnConditionCheckFailure` is available for all [single-item write operations](/docs/dev-guide/high-level/write) and [transactional writes](/docs/dev-guide/high-level/transact#transactwriteitems).\\n:::\\n\\n## More predefined region endpoints\\n\\nSince the initial release of EfficientDynamoDb, several new AWS regions have been introduced.\\nWhile it was always possible to [create regions dynamically](/docs/dev-guide/configuration/region-endpoint#create-regions-dynamically), all regions supported by DynamoDB are now available as static properties of `RegionEndpoint`.\\n\\nList of new regions added in EfficientDynamoDb 0.9.15:\\n\\n* `ap-south-2` - Asia Pacific (Hyderabad)\\n* `ap-southeast-3` - Asia Pacific (Jakarta)\\n* `ap-southeast-4` - Asia Pacific (Melbourne)\\n* `eu-central-2` - Europe (Zurich)\\n* `eu-south-2` - Europe (Spain)\\n* `me-central-1` - Middle East (UAE)\\n* `il-central-1` - Israel (Tel Aviv)\\n\\n## Other improvements\\n\\n* Error parsing was tuned to handle the most frequent DynamoDB errors more efficiently.\\n* Added XML docs for UpdateExpression builder to improve developer experience."},{"id":"welcome","metadata":{"permalink":"/EfficientDynamoDb/blog/welcome","editUrl":"https://github.com/alloczero/EfficientDynamoDb/edit/main/website/blog/blog/2021-03-30-welcome.md","source":"@site/blog/2021-03-30-welcome.md","title":"Welcome","description":"We\'re thrilled to announce our first publicly available Release Candidate version of EfficientDynamoDb.","date":"2021-03-30T00:00:00.000Z","formattedDate":"March 30, 2021","tags":[{"label":"dynamodb","permalink":"/EfficientDynamoDb/blog/tags/dynamodb"},{"label":"dotnet","permalink":"/EfficientDynamoDb/blog/tags/dotnet"},{"label":"c#","permalink":"/EfficientDynamoDb/blog/tags/c"},{"label":"aws","permalink":"/EfficientDynamoDb/blog/tags/aws"}],"readingTime":1.095,"hasTruncateMarker":false,"authors":[{"name":"Mykhailo Matviiv","url":"https://github.com/firenero","imageURL":"https://avatars.githubusercontent.com/u/9461703?s=400&u=a677c383395a1debb6ae6fe1a50d6b039b28f203&v=4"}],"frontMatter":{"slug":"welcome","title":"Welcome","author":"Mykhailo Matviiv","author_url":"https://github.com/firenero","author_image_url":"https://avatars.githubusercontent.com/u/9461703?s=400&u=a677c383395a1debb6ae6fe1a50d6b039b28f203&v=4","tags":["dynamodb","dotnet","c#","aws"]},"prevItem":{"title":"What\'s New in EfficientDynamoDb 0.9.15","permalink":"/EfficientDynamoDb/blog/whats-new-0.9.15"}},"content":"We\'re thrilled to announce our first publicly available Release Candidate version of [EfficientDynamoDb](https://github.com/AllocZero/EfficientDynamoDb).\\n\\nIt aims to simplify major pain points of interacting with DynamoDB in C# that we faced in more than 4 years working with it:\\n\\n1. Unreasonably slow response processing. In some cases, parsing the result is slower than DynamoDB latency.\\n1. Expressions syntax (query, update, etc.) is not suitable for C# tooling. Using strings for expressions is highly error-prone, hides usages, makes refactoring challenging, and has no validation whatsoever.\\n1. Missing high-level APIs for transactions, batches, updates.\\n1. Poor out-of-the-box data types support (especially collections) and limited extensibility.\\n\\nWe\'ve put dozens of hours optimizing hot paths in our library to ensure that every single benchmark outperforms competitors. In some popular scenarios, EfficientDynamoDb can be up to 21x times faster and allocate 26x times less memory.\\n\\nIt\'s possible to build DDB expressions entirely in C# without using clumsy DDB expressions syntax and plain strings. Complicated operations like transactions, batches, updates, and parallel scans are easy to use via high-level API.\\n\\nWe have many ideas moving forward, like integrating composite keys, smart retry policies, supporting get-only properties, and so on. We\'d love to hear the feedback from the community, so feel free to create an issue on [GitHub](https://github.com/AllocZero/EfficientDynamoDb) or post your questions and suggestions here in the comments."}]}')}}]);