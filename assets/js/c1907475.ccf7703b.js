"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5521],{1779:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"dev_guide/configuration/retry-strategies","title":"Retry Strategies","description":"Why do you need retries","source":"@site/docs/dev_guide/configuration/retry-strategies.md","sourceDirName":"dev_guide/configuration","slug":"/dev-guide/configuration/retry-strategies","permalink":"/EfficientDynamoDb/docs/dev-guide/configuration/retry-strategies","draft":false,"unlisted":false,"editUrl":"https://github.com/alloczero/EfficientDynamoDb/edit/main/website/docs/dev_guide/configuration/retry-strategies.md","tags":[],"version":"current","frontMatter":{"id":"retry-strategies","title":"Retry Strategies","slug":"../../dev-guide/configuration/retry-strategies"},"sidebar":"someSidebar","previous":{"title":"Credentials management","permalink":"/EfficientDynamoDb/docs/dev-guide/configuration/credentials"},"next":{"title":"Attributes","permalink":"/EfficientDynamoDb/docs/dev-guide/high-level/attributes"}}');var n=r(3420),s=r(5404);const a={id:"retry-strategies",title:"Retry Strategies",slug:"../../dev-guide/configuration/retry-strategies"},o=void 0,l={},c=[{value:"Why do you need retries",id:"why-do-you-need-retries",level:2},{value:"Retries in EfficientDynamoDb",id:"retries-in-efficientdynamodb",level:2},{value:"Default retry strategies",id:"default-retry-strategies",level:3},{value:"Predefined retry strategies",id:"predefined-retry-strategies",level:2},{value:"LinearRetryStrategy",id:"linearretrystrategy",level:3},{value:"JitterRetryStrategy",id:"jitterretrystrategy",level:3},{value:"Implementing custom retry strategy",id:"implementing-custom-retry-strategy",level:2},{value:"Best practices",id:"best-practices",level:3},{value:"Applying retry strategy",id:"applying-retry-strategy",level:2}];function d(e){const t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h2,{id:"why-do-you-need-retries",children:"Why do you need retries"}),"\n",(0,n.jsxs)(t.p,{children:["While working with DynamoDB, it's common to encounter transient errors, such as rate limiting.\nMany of these errors are considered ",(0,n.jsx)(t.em,{children:"normal"})," behavior, to some degree, and should be handled appropriately.\nImplementing effective retry strategies ensures smooth operations, mitigating the impact of such occasional disruptions.\nUnderstanding why and how to handle retries in DynamoDB is crucial for consistent performance and resilience."]}),"\n",(0,n.jsx)(t.p,{children:"Though the concept of implementing retries might seem straightforward, the actual execution can be complex and error-prone.\nIf retries are set up incorrectly, they can easily overwhelm your system.\nWith DynamoDB, a poor retry strategy can increase the cost and latency of your application."}),"\n",(0,n.jsx)(t.h2,{id:"retries-in-efficientdynamodb",children:"Retries in EfficientDynamoDb"}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"EfficientDynamoDb"})," aims to simplify retries so that you don't have to handle them in your business layer.\nYou can specify a desired ",(0,n.jsx)(t.code,{children:"RetryStrategy"})," for every retriable issue that can happen while interacting with DynamoDB."]}),"\n",(0,n.jsx)(t.p,{children:"EfficientDynamoDb supports retries for the following errors:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"InternalServerErrorStrategy"})," - Internal server error happened on AWS."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"LimitExceededStrategy"})," - There are too many concurrent control plane operations.\nThe cumulative number of tables and indexes in the ",(0,n.jsx)(t.code,{children:"CREATING"}),", ",(0,n.jsx)(t.code,{children:"DELETING"}),", or ",(0,n.jsx)(t.code,{children:"UPDATING"})," state cannot exceed 50."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"ProvisionedThroughputExceededStrategy"})," - Maximum allowed provisioned throughput for a table or for one or more global secondary indexes was exceeded."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"RequestLimitExceededStrategy"})," - Throughput exceeds the current throughput limit for the account."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"ServiceUnavailableStrategy"})," - DynamoDB is currently unavailable. (This should be a temporary state.)"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"ThrottlingStrategy"})," - Control plane API operations are performed too rapidly."]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["EfficientDynamoDb has sensible default retry strategies set for every retriable error.\nThey are the best choice for the vast majority of DynamoDB users.\nAt the same time, we provide an easy way to tune existing strategies or ",(0,n.jsx)(t.a,{href:"#implementing-custom-retry-strategy",children:"implement your own"})," from scratch."]}),"\n",(0,n.jsx)(t.h3,{id:"default-retry-strategies",children:"Default retry strategies"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Error category"}),(0,n.jsx)(t.th,{children:"Retry configuration"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"InternalServerError"}),(0,n.jsx)(t.td,{children:"Linear (5 attempts, 50ms delay)"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"LimitExceeded"}),(0,n.jsx)(t.td,{children:"Linear (5 attempts, 50ms delay)"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"ProvisionedThroughputExceeded"}),(0,n.jsx)(t.td,{children:"Jitter (5 attempts, 50ms delay, 16s max delay)"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"RequestLimitExceeded"}),(0,n.jsx)(t.td,{children:"Jitter (5 attempts, 50ms delay, 16s max delay)"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"ServiceUnavailable"}),(0,n.jsx)(t.td,{children:"Linear (5 attempts, 50ms delay)"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Throttling"}),(0,n.jsx)(t.td,{children:"Jitter (5 attempts, 50ms delay, 16s max delay)"})]})]})]}),"\n",(0,n.jsx)(t.h2,{id:"predefined-retry-strategies",children:"Predefined retry strategies"}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"EfficientDynamoDb"})," package contains predefined retry strategies that are most common and suit most DynamoDB users. They can be created via ",(0,n.jsx)(t.a,{href:"https://github.com/AllocZero/EfficientDynamoDb/blob/main/src/EfficientDynamoDb/Configs/Retries/RetryStrategyFactory.cs",children:"RetryStrategyFactory"}),"."]}),"\n",(0,n.jsx)(t.h3,{id:"linearretrystrategy",children:"LinearRetryStrategy"}),"\n",(0,n.jsx)(t.p,{children:"The most simple retry policy. It retries 5 times with 50ms delays between attempts. Delay and max retries count are configurable."}),"\n",(0,n.jsx)(t.p,{children:"Example:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-csharp",children:"var strategy = RetryStrategyFactory.Linear(maxRetriesCount: 10, delayMs: 25);\n"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.a,{href:"https://github.com/AllocZero/EfficientDynamoDb/blob/main/src/EfficientDynamoDb/Configs/Retries/LinearRetryStrategy.cs",children:"Sources"})}),"\n",(0,n.jsx)(t.h3,{id:"jitterretrystrategy",children:"JitterRetryStrategy"}),"\n",(0,n.jsx)(t.p,{children:"Exponential backoff strategy with jitter. Designed to spread out the load to an approximately constant rate. Useful for handling DDB throttling exceptions and similar cases."}),"\n",(0,n.jsxs)(t.p,{children:["Represents ",(0,n.jsx)(t.code,{children:"FullJitter"})," retry strategy from this ",(0,n.jsx)(t.a,{href:"https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/",children:"AWS article"}),"."]}),"\n",(0,n.jsx)(t.p,{children:"Example:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-csharp",children:"var strategy = RetryStrategyFactory.Jitter(maxRetriesCount: 10, baseDelayMs: 25, maxDelayMs: 400);\n"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.a,{href:"https://github.com/AllocZero/EfficientDynamoDb/blob/main/src/EfficientDynamoDb/Configs/Retries/JitterRetryStrategy.cs",children:"Sources"})}),"\n",(0,n.jsx)(t.h2,{id:"implementing-custom-retry-strategy",children:"Implementing custom retry strategy"}),"\n",(0,n.jsxs)(t.p,{children:["All retry strategies must implement the ",(0,n.jsx)(t.a,{href:"https://github.com/AllocZero/EfficientDynamoDb/blob/main/src/EfficientDynamoDb/Configs/Retries/IRetryStrategy.cs",children:"IRetryStrategy"})," interface.\nIt contains a single ",(0,n.jsx)(t.code,{children:"bool TryGetRetryDelay(int attempt, out TimeSpan delay)"})," method to calculate the actual delay required for the specified retry attempt."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Parameters:"})}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"int attempt"})," - 0-based index of the retry attempt.\nE.g., for the first retry value of ",(0,n.jsx)(t.code,{children:"attempt"})," is ",(0,n.jsx)(t.code,{children:"0"}),", and for the 3rd retry, it is ",(0,n.jsx)(t.code,{children:"2"}),"."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"out TimeSpan delay"})," - out parameter that contains a calculated delay for the specified attempt."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Returns:"})}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"false"})," if retry shouldn't happen, e.g., when the maximum number of retries is reached. Otherwise, return ",(0,n.jsx)(t.code,{children:"true"}),"."]}),"\n",(0,n.jsx)(t.h3,{id:"best-practices",children:"Best practices"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:"Make sure your strategy implementation is thread-safe if you share it across different retriable issues."}),"\n",(0,n.jsx)(t.li,{children:"Try to keep the strategy simple to avoid performance degradations due to complex calculations combined with frequent retries."}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"applying-retry-strategy",children:"Applying retry strategy"}),"\n",(0,n.jsxs)(t.p,{children:["Retry strategies in EfficientDynamoDb are applied at the context level.\n",(0,n.jsx)(t.code,{children:"DynamoDbContextConfig"})," provides an API to set any strategies you want.\nDefaults will be used for all unset properties."]}),"\n",(0,n.jsx)(t.p,{children:"Example:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-csharp",children:'var config = new DynamoDbContextConfig(RegionEndpoint.USEast1, new AwsCredentials("public", "secret"));\nconfig.RetryStrategies.ThrottlingStrategy = RetryStrategyFactory.Jitter(baseDelayMs: 100);\n'})})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},5404:(e,t,r)=>{r.d(t,{R:()=>a,x:()=>o});var i=r(6672);const n={},s=i.createContext(n);function a(e){const t=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);