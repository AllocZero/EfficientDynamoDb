(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{119:function(e,t,r){"use strict";r.d(t,"a",(function(){return p})),r.d(t,"b",(function(){return v}));var n=r(0),o=r.n(n);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function l(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function c(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var s=o.a.createContext({}),d=function(e){var t=o.a.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):l(l({},t),e)),r},p=function(e){var t=d(e.components);return o.a.createElement(s.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},u=o.a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,a=e.originalType,i=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),p=d(r),u=n,v=p["".concat(i,".").concat(u)]||p[u]||b[u]||a;return r?o.a.createElement(v,l(l({ref:t},s),{},{components:r})):o.a.createElement(v,l({ref:t},s))}));function v(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var a=r.length,i=new Array(a);i[0]=u;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:n,i[1]=l;for(var s=2;s<a;s++)i[s]=r[s];return o.a.createElement.apply(null,i)}return o.a.createElement.apply(null,r)}u.displayName="MDXCreateElement"},83:function(e,t,r){"use strict";r.r(t),r.d(t,"frontMatter",(function(){return i})),r.d(t,"metadata",(function(){return l})),r.d(t,"toc",(function(){return c})),r.d(t,"default",(function(){return d}));var n=r(3),o=r(7),a=(r(0),r(119)),i={id:"converters",title:"Custom Converters",slug:"../dev-guide/high-level/converters"},l={unversionedId:"dev_guide/high_level/converters",id:"dev_guide/high_level/converters",isDocsHomePage:!1,title:"Custom Converters",description:"A converter is a class that converts .NET type to and from DynamoDb JSON or low-level Document object. A custom converter allows to work with unsupported types or to override the default converter behavior.",source:"@site/docs/dev_guide/high_level/converters.md",slug:"/dev_guide/dev-guide/high-level/converters",permalink:"/EfficientDynamoDb/docs/dev_guide/dev-guide/high-level/converters",editUrl:"https://github.com/alloczero/EfficientDynamoDb/edit/master/website/docs/dev_guide/high_level/converters.md",version:"current",sidebar:"someSidebar",previous:{title:"Transact",permalink:"/EfficientDynamoDb/docs/dev_guide/dev-guide/high-level/transact"},next:{title:"Building Conditions",permalink:"/EfficientDynamoDb/docs/dev_guide/dev-guide/high-level/conditions"}},c=[{value:"Basic converter",id:"basic-converter",children:[]},{value:"Applying converters",id:"applying-converters",children:[{value:"For property",id:"for-property",children:[]},{value:"For type",id:"for-type",children:[]},{value:"For context",id:"for-context",children:[]}]},{value:"Direct JSON converter",id:"direct-json-converter",children:[{value:"JSON reading",id:"json-reading",children:[]},{value:"JSON writing",id:"json-writing",children:[]}]},{value:"Sparse converters",id:"sparse-converters",children:[]},{value:"Set converters",id:"set-converters",children:[]},{value:"Dictionary key converters",id:"dictionary-key-converters",children:[]}],s={toc:c};function d(e){var t=e.components,r=Object(o.a)(e,["components"]);return Object(a.b)("wrapper",Object(n.a)({},s,r,{components:t,mdxType:"MDXLayout"}),Object(a.b)("p",null,"A converter is a class that converts .NET type to and from DynamoDb JSON or low-level ",Object(a.b)("inlineCode",{parentName:"p"},"Document")," object. A custom converter allows to work with unsupported types or to override the default converter behavior."),Object(a.b)("p",null,"Converters on par with DynamoDb JSON parsing are one of the most critical components from the performance point of view.\nAll ",Object(a.b)("strong",{parentName:"p"},"EfficientDynamoDb")," built-in converters are optimized separately for entity to ",Object(a.b)("inlineCode",{parentName:"p"},"Document"),"  and entity to JSON conversions in order to allocate no additional memory."),Object(a.b)("h2",{id:"basic-converter"},"Basic converter"),Object(a.b)("p",null,"To create a custom converter:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Inherit from ",Object(a.b)("inlineCode",{parentName:"li"},"DdbConverter<TValue>")," class."),Object(a.b)("li",{parentName:"ul"},"Implement both ",Object(a.b)("inlineCode",{parentName:"li"},"Read")," and ",Object(a.b)("inlineCode",{parentName:"li"},"Write")," methods.")),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-csharp"},"public class CompositeAddressConverter : DdbConverter<Address>\n{\n    // Converts DynamoDb attribute to the .NET type\n    public override Address Read(in AttributeValue attributeValue)\n    {\n        var parts = attributeValue.AsString().Split('#');\n        return new Address(parts[0], parts[1]);\n    }\n\n    // Converts .NET type to the DynamoDb attribute\n    public override AttributeValue Write(ref Address address)\n    {\n        return new StringAttributeValue($\"{address.Country}#{address.Street}\");\n    }\n}\n")),Object(a.b)("p",null,Object(a.b)("em",{parentName:"p"},"Check out the ",Object(a.b)("a",{parentName:"em",href:"/EfficientDynamoDb/docs/dev-guide/low-level#working-with-documents"},"working with documents")," chapter to better understand how to work with attribute values.")),Object(a.b)("h2",{id:"applying-converters"},"Applying converters"),Object(a.b)("h3",{id:"for-property"},"For property"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-csharp"},'[DynamoDbProperty("address", typeof(CompositeAddressConverter))]\npublic Address Address { get; set; }\n')),Object(a.b)("h3",{id:"for-type"},"For type"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-csharp"},"[DynamoDBConverter(typeof(CompositeAddressConverter))]\npublic struct Address { ... }\n")),Object(a.b)("h3",{id:"for-context"},"For context"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-csharp"},"var config = new DynamoDbContextConfig(regionEndpoint, awsCredentials)\n{\n    Converters = new[] {new CompositeAddressConverter()}\n};\n")),Object(a.b)("p",null,"If converter can't be instantiated in advance and depends on the target value type, a custom converter factory can be implemented by inheriting from the ",Object(a.b)("inlineCode",{parentName:"p"},"DdbConverterFactory")," class and registering it for context the same way as other custom converters."),Object(a.b)("p",null,"For example, a string enum converter factory can be defined like this:"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-csharp"},"public sealed class StringEnumDdbConverterFactory : DdbConverterFactory\n{\n    public override bool CanConvert(Type typeToConvert) => typeToConvert.IsEnum;\n\n    public override DdbConverter CreateConverter(Type typeToConvert, DynamoDbContextMetadata metadata)\n    {\n        return (DdbConverter) Activator.CreateInstance(typeof(StringEnumDdbConverter<>).MakeGenericType(typeToConvert));\n    }\n}\n")),Object(a.b)("h2",{id:"direct-json-converter"},"Direct JSON converter"),Object(a.b)("p",null,"Not all .NET types map nicely to DynamoDb attributes. Creation of intermediate ",Object(a.b)("inlineCode",{parentName:"p"},"AttributeValue")," struct can involve unnecessary allocations that can be avoided by reading / writing directly into JSON buffer.\nIn case when a custom type can't be converted to the ",Object(a.b)("inlineCode",{parentName:"p"},"AttributeValue")," without allocations, it is possible to implement two additional low-level ",Object(a.b)("inlineCode",{parentName:"p"},"Read")," and ",Object(a.b)("inlineCode",{parentName:"p"},"Write")," methods that work with JSON buffers.\nDuring deserialization / serialization of entities to JSON, more optimized low-level implementations will be called."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-csharp"},"public class CustomIntConverter : DdbConverter<int>\n{\n    // Efficient zero-allocation JSON to int conversion\n    public override int Read(ref DdbReader reader)\n    {\n        if (!Utf8Parser.TryParse(reader.JsonReader.ValueSpan, out int value, out _))\n            throw new DdbException($\"Couldn't parse int ddb value from '{reader.JsonReaderValue.GetString()}'.\");\n\n        return value;\n    }\n    \n    // Efficient zero-allocation int to JSON conversion\n    public override void Write(in DdbWriter writer, ref int value)\n    {\n         writer.JsonWriter.WriteStartObject();\n         writer.JsonWriter.WriteString(DdbTypeNames.Number, value);\n         writer.JsonWriter.WriteEndObject();\n    }\n    \n    public override int Read(in AttributeValue attributeValue) => attributeValue.AsNumberAttribute().ToInt();\n    \n    public override AttributeValue Write(ref T value) => new NumberAttributeValue(value.ToString());   \n}\n")),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"EfficientDynamoDb")," uses ",Object(a.b)("inlineCode",{parentName:"p"},"System.Text.Json")," for all JSON manipulations. "),Object(a.b)("h3",{id:"json-reading"},"JSON reading"),Object(a.b)("p",null,"When a low-level read is called, ",Object(a.b)("inlineCode",{parentName:"p"},"DdbReader.JsonReader")," is already pointed to the JSON value. Current attribute type is automatically parsed and can be accessed using ",Object(a.b)("inlineCode",{parentName:"p"},"DdbReader.AttributeType")," property."),Object(a.b)("p",null,"The ",Object(a.b)("inlineCode",{parentName:"p"},"DdbReader.JsonReader.Read")," method should not be called explicitly unless you are writing a converter for a non-primitive JSON type like an object or array."),Object(a.b)("h3",{id:"json-writing"},"JSON writing"),Object(a.b)("p",null,"When a low-level write is called, a converter has to write DynamoDb JSON including the attribute type.\n",Object(a.b)("inlineCode",{parentName:"p"},"DdbWriter")," class provides various simplified overloads that write attribute types automatically. But in case if suitable overload does not exist, attribute type has to be written manually like in the ",Object(a.b)("inlineCode",{parentName:"p"},"CustomIntConverter")," example above."),Object(a.b)("h2",{id:"sparse-converters"},"Sparse converters"),Object(a.b)("p",null,"Sparse converters don't save certain values and completely remove an attribute instead. It is a powerful concept that can be used for various purposes like size savings or to conditionally include an entity in the GSI."),Object(a.b)("p",null,"By default all built-in converters act as sparse converters when it comes to handling ",Object(a.b)("inlineCode",{parentName:"p"},"null")," values, meaning that ",Object(a.b)("inlineCode",{parentName:"p"},"null")," properties are never saved and entire attribute is deleted."),Object(a.b)("p",null,"To add an additional sparse condition, ",Object(a.b)("inlineCode",{parentName:"p"},"ShouldWrite")," method has to be overriden. For example. here is a simple sparse int converter:"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-csharp"},"public class SparseIntConverter : DdbConverter<int>\n{\n    public override bool ShouldWrite(ref int value) => value != 0;\n    \n    ...\n}\n")),Object(a.b)("p",null,"Note: Sparse converters don't remove attributes when they are part of a ",Object(a.b)("inlineCode",{parentName:"p"},"Dictionary")," class."),Object(a.b)("h2",{id:"set-converters"},"Set converters"),Object(a.b)("p",null,"Both string and number sets store values as strings in the db.\nTo store a custom type inside a set, a converter should implement the ",Object(a.b)("inlineCode",{parentName:"p"},"ISetValueConverter<T>")," interface:"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-csharp"},"public class CustomDdbConverter : DdbConverter<CustomType>, ISetValueConverter<CustomType>\n{\n    public string WriteStringValue(ref CustomType value) => value.ToString();\n    \n    // Optionally implement direct write method\n    public void WriteStringValue(in DdbWriter ddbWriter, ref CustomType value) => \n        ddbWriter.JsonWriter.WriteStringValue(value.AsSpan());\n}\n")),Object(a.b)("h2",{id:"dictionary-key-converters"},"Dictionary key converters"),Object(a.b)("p",null,"To store a custom type as a dictionary key, a converter should implement the ",Object(a.b)("inlineCode",{parentName:"p"},"IDicitonaryKeyConverter<T>")," interface:"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-csharp"},"public class CustomDdbConverter : DdbConverter<CustomType>, ISetValueConverter<CustomType>\n{\n    public string WriteStringValue(ref CustomType value) => value.ToString();\n    \n    // Optionally implement direct write method\n    public void WritePropertyName(in DdbWriter ddbWriter, ref CustomType value) => \n        ddbWriter.JsonWriter.WritePropertyName(value.AsSpan());\n}\n")))}d.isMDXComponent=!0}}]);